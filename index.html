<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agni's Balloon Shooter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght @400;700&family=Wallpoet&display=swap');
        
        /* Define Neon Colors */
        :root {
            --neon-color: #39ff14; /* Neon Green */
            --dark-bg: #111827; /* Dark Slate */
            --text-color: #f3f4f6;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--dark-bg);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }
        
        /* Neon Glow Effect */
        .neon-glow {
            text-shadow: 0 0 5px var(--neon-color), 0 0 10px var(--neon-color), 0 0 20px var(--neon-color);
        }

        /* Canvas Styling */
        canvas {
            display: block;
            background-color: #0c1815; /* Darker green tint */
            border-radius: 1rem;
            border: 2px solid var(--neon-color);
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.6), 0 0 20px rgba(57, 255, 20, 0.4);
            margin-top: 1rem;
            cursor: none;
            transition: box-shadow 0.3s;
        }

        /* Popup Styling */
        .popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7); 
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .popup-content {
            padding: 1.5rem; 
            border-radius: 1rem;
            max-width: 90%;
            width: 380px; 
            background-color: #1f2937;
            border: 2px solid var(--neon-color);
            box-shadow: 0 0 15px rgba(57, 255, 20, 0.8);
            color: var(--text-color);
        }
        
        /* Button Styling (Neon) */
        .control-button {
            transition: all 0.2s, box-shadow 0.3s;
            background-color: #1f2937;
            border: 1px solid var(--neon-color);
            color: var(--neon-color);
            box-shadow: 0 0 5px rgba(57, 255, 20, 0.6);
        }
        .control-button:hover {
            transform: scale(1.05);
            background-color: var(--neon-color);
            color: var(--dark-bg);
            box-shadow: 0 0 15px var(--neon-color), 0 0 25px var(--neon-color);
        }

        /* Scoreboard & Lives */
        #scoreboard, #lives-display {
            font-family: 'Wallpoet', monospace;
            color: var(--neon-color);
            background-color: #1f2937;
            border: 1px solid var(--neon-color);
            box-shadow: 0 0 5px rgba(57, 255, 20, 0.8);
            transition: box-shadow 0.2s;
        }

        /* Styling for the mobile fire button to be fixed */
        #fire-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 70px;
            height: 70px;
            z-index: 500;
        }
        
        /* Animation for life loss feedback */
        @keyframes life-lost-flash {
            0% { background-color: #ff0000; color: white; }
            100% { background-color: transparent; color: var(--neon-color); }
        }

        .life-lost {
            animation: life-lost-flash 0.3s ease-out;
        }

        /* Utility for touch devices, hides controls when touch is detected */
        @media (min-width: 768px) {
            #fire-btn {
                display: none;
            }
        }
    </style>
</head>
<body class="flex flex-col items-center p-4 min-h-screen">

    <!-- Header: Title centered, Scores/Lives below -->
    <header class="w-full max-w-2xl flex flex-col mb-4">
        <!-- New Centered Title -->
        <h1 class="text-4xl font-bold text-white neon-glow text-center mb-4 font-['Wallpoet']">Agni's Bubble Shooter</h1>
        
        <!-- Scores and Lives Row -->
        <div class="flex justify-between items-center">
            <!-- Lives Display -->
            <div id="lives-display" class="text-2xl font-mono px-4 py-2 rounded-lg shadow flex items-center space-x-2">
                <!-- Hearts will be injected here by JS -->
            </div>
    
            <!-- Scoreboard -->
            <div id="scoreboard" class="text-xl font-mono px-4 py-2 rounded-lg shadow">Score: 0</div>
        </div>
    </header>

    <!-- Control Bar -->
    <div class="w-full max-w-2xl flex justify-center items-center space-x-2 md:space-x-4 mb-4">
        <button id="pause-play-btn" class="control-button font-bold py-2 px-4 rounded-full">Pause</button>
        <button id="sound-toggle-btn" class="control-button font-bold py-2 px-4 rounded-full">Sound Off</button>
        <!-- Theme toggle is permanently hidden for the neon theme -->
        <button id="theme-toggle-btn" class="control-button font-bold py-2 px-4 rounded-full hidden">Dark/Light</button>
    </div>

    <!-- Powerup Status -->
    <div id="powerup-status" class="w-full max-w-2xl text-center text-lg font-semibold neon-glow text-red-400 mb-2 h-6"></div>

    <!-- Game Canvas -->
    <canvas id="game-canvas" class="w-full max-w-2xl"></canvas>
    
    <!-- Mobile Fire Button -->
    <button id="fire-btn" class="control-button bg-red-800 hover:bg-red-900 text-white font-bold rounded-full flex items-center justify-center text-3xl">
        &#x1F52B; <!-- Pistol emoji -->
    </button>

    <!-- Audio Elements (Muted by default to prevent auto-play policy issues) -->
    <audio id="shoot-sound" src="shoot.wav" preload="auto" muted></audio>
    <audio id="pop-sound" src="pop.mp3" preload="auto" muted></audio>
    <audio id="bg-music" src="bg-music.mp3" loop preload="auto" muted></audio>
    
    <!-- NEW AUDIO ELEMENTS -->
    <!-- Bomb Blast (Game Over) Sound -->
    <audio id="bomb-blast-sound" src="https://freesound.org/data/previews/143/143929_2393247-lq.mp3" preload="auto" muted></audio>
    <!-- Powerup (Gun/Shield/Life) Pickup Sound (Chime) -->
    <audio id="powerup-sound" src="https://freesound.org/data/previews/186/186851_2069818-lq.mp3" preload="auto" muted></audio>
    <!-- Life Loss/Hit Sound (Negative Buzzer) -->
    <audio id="life-loss-sound" src="https://freesound.org/data/previews/327/327318_5625725-lq.mp3" preload="auto" muted></audio>


    <!-- 1. Instruction/Start Popup -->
    <div id="instruction-popup" class="popup">
        <div class="popup-content text-center">
            <h2 class="text-3xl font-bold mb-4 neon-glow text-white">Agni's Balloon Shooter Instructions</h2>
            <p class="mb-4">Defend your artillery gun! You have <span class="text-red-400 font-bold">5 LIVES</span>. Lose a life if a non-bomb balloon reaches the bottom.</p>
            
            <div class="mb-6 p-3 bg-gray-800 rounded-lg">
                <p class="font-semibold mb-2 text-white">Controls:</p>
                <ul class="text-sm list-disc list-inside space-y-1 text-gray-300">
                    <li>Move: Arrow Keys (Left/Right) or Mouse/Touch Drag.</li>
                    <li>Fire: Spacebar or the Fire button (touch).</li>
                </ul>
                <p class="mt-2 text-sm text-yellow-300">Look out for **üî´ Gun**, **‚ô• Life**, and **üõ°Ô∏è Shield** power-ups! Power-ups are rare.</p>
                <p class="mt-2 text-sm text-red-400 font-bold">WARNING: Hitting a bomb (üíÄ) is instant Game Over!</p>
            </div>

            <div class="mb-6">
                <label for="difficulty" class="block text-xl font-semibold mb-2">Difficulty (Balloon Spawn Rate):</label>
                <input type="range" id="difficulty" min="1" max="10" value="5" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                <div class="flex justify-between text-sm mt-1">
                    <span>Easy (1)</span>
                    <span>Hard (10)</span>
                </div>
            </div>

            <button class="close-button font-bold py-3 px-8 rounded-full text-lg control-button hover:bg-indigo-700">
                START GAME
            </button>
        </div>
    </div>

    <!-- 2. Game Over Popup -->
    <div id="game-over-popup" class="popup hidden">
        <div class="popup-content text-center border-red-500 bg-red-900/50">
            <h2 class="text-4xl font-extrabold mb-4 text-red-400 neon-glow">GAME OVER!</h2>
            <p class="text-2xl mb-4 text-white">Final Score: <span id="final-score" class="font-mono text-red-200 neon-glow">0</span></p>
            <p class="mb-6 text-gray-200">Lives ran out or you shot a bomb!</p>
            <button class="start-button font-bold py-3 px-8 rounded-full text-lg control-button hover:bg-green-700">
                PLAY AGAIN
            </button>
        </div>
    </div>

    <script>
        // --- GAME INITIALIZATION ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const instructionPopup = document.getElementById('instruction-popup');
        const gameOverPopup = document.getElementById('game-over-popup');
        const closeButton = instructionPopup.querySelector('.close-button');
        const startButton = gameOverPopup.querySelector('.start-button');
        const scoreboard = document.getElementById('scoreboard');
        const finalScoreEl = document.getElementById('final-score');
        const livesDisplay = document.getElementById('lives-display');
        const pausePlayBtn = document.getElementById('pause-play-btn');
        const soundToggleBtn = document.getElementById('sound-toggle-btn');
        const themeToggleBtn = document.getElementById('theme-toggle-btn');
        const fireBtn = document.getElementById('fire-btn');
        const powerupStatusEl = document.getElementById('powerup-status');

        const difficultySlider = document.getElementById('difficulty');

        // Audio Elements
        const shootSound = document.getElementById('shoot-sound');
        const popSound = document.getElementById('pop-sound');
        const bgMusic = document.getElementById('bg-music');
        const bombBlastSound = document.getElementById('bomb-blast-sound');
        const powerupSound = document.getElementById('powerup-sound');
        const lifeLossSound = document.getElementById('life-loss-sound');

        // Game State
        let player;
        let projectiles = [];
        let balloons = [];
        let particles = [];
        let gunPowerups = [];
        let lifePowerups = [];
        let shieldPowerups = [];
        let score = 0;
        let lives = 5;
        const MAX_LIVES = 5;
        let gameRunning = false;
        let isPaused = false;
        let isMuted = true;
        let keys = {};
        let isShooting = false;
        let shootInterval;
        let balloonSpawnRate;
        let animationFrameId;

        // Power-up state
        let multiGunActive = false;
        let multiGunTimer = 0; // Frames remaining
        let shieldActive = false;
        let shieldTimer = 0; // Frames remaining

        // --- GAME CLASSES ---

        class Player {
            constructor() {
                this.width = 100;
                this.height = 30; // Logical height, visual is taller
                this.x = canvas.width / 2 - this.width / 2;
                this.y = canvas.height; // Positioned at the very bottom
                this.speed = 10;
                this.barrelAngle = -90 * (Math.PI / 180); // Straight up
                this.barrelLength = 60;
                this.barrelWidth = 15;
                this.lastX = this.x; // For tracking movement direction

                // Constants for drawing the cannon
                this.BASE_VISUAL_HEIGHT = 60;
                this.PIVOT_RADIUS = 18;
                this.BARREL_LENGTH_MULTIPLIER = 1.6;
            }

            // Returns the main pivot point for the barrel
            _getPivot() {
                const centerX = this.x + this.width / 2;
                const topOfBaseY = this.y - this.BASE_VISUAL_HEIGHT;
                const pivotY = topOfBaseY + this.PIVOT_RADIUS;
                return { x: centerX, y: pivotY };
            }

            // Returns the position of the main barrel's tip
            getBarrelTip() {
                const pivot = this._getPivot();
                const actualBarrelLength = this.barrelLength * this.BARREL_LENGTH_MULTIPLIER;
                const tipX = pivot.x + actualBarrelLength * Math.cos(this.barrelAngle);
                const tipY = pivot.y + actualBarrelLength * Math.sin(this.barrelAngle);
                return { x: tipX, y: tipY };
            }

            draw() {
                const TOWER_COLOR = '#3B3C42';
                const ARMOR_COLOR = '#6E737C';
                const PIVOT_COLOR = '#9C9EA3';
                const BARREL_COLOR = '#44464D';

                const pivot = this._getPivot();
                const topOfBaseY = this.y - this.BASE_VISUAL_HEIGHT;

                // 1. Draw the Armored Base
                ctx.fillStyle = '#2A2B30';
                ctx.fillRect(this.x, this.y - 10, this.width, 10);
                ctx.fillStyle = TOWER_COLOR;
                ctx.fillRect(this.x + 5, this.y - this.BASE_VISUAL_HEIGHT, this.width - 10, this.BASE_VISUAL_HEIGHT);
                ctx.fillStyle = ARMOR_COLOR;
                ctx.beginPath();
                ctx.moveTo(this.x + 5, topOfBaseY + 15);
                ctx.lineTo(this.x + 5, this.y - 10);
                ctx.lineTo(this.x + this.width - 5, this.y - 10);
                ctx.lineTo(this.x + this.width - 5, topOfBaseY + 15);
                ctx.fill();

                // 2. Draw the Gun Mount (Pivot)
                ctx.fillStyle = PIVOT_COLOR;
                ctx.beginPath();
                ctx.arc(pivot.x, pivot.y, this.PIVOT_RADIUS, 5, Math.PI * 2);
                ctx.fill();

                // 3. Draw the Barrel(s)
                const actualBarrelLength = this.barrelLength * this.BARREL_LENGTH_MULTIPLIER;
                const actualBarrelWidth = this.barrelWidth;

                // --- Barrel Drawing Logic ---
                const drawBarrel = (rotationOffset, width, length, color) => {
    ctx.save();
    ctx.translate(pivot.x, pivot.y); // Pivot should be where barrel "attaches"
    ctx.rotate(this.barrelAngle + rotationOffset - Math.PI / 2); // Rotate upright
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.rect(-width / 2, 0, width, -length); // Start at the pivot, draw upwards
    ctx.fill();
    ctx.restore();
};


                if (multiGunActive) {
                    const sideBarrelLength = actualBarrelLength * 0.85;
                    const sideBarrelWidth = actualBarrelWidth * 0.75;
                    const angleOffset = 15 * (Math.PI / 180);
                    // Draw side barrels first so main is on top
                    drawBarrel(-angleOffset, sideBarrelWidth, sideBarrelLength, BARREL_COLOR); // Left
                    drawBarrel(angleOffset, sideBarrelWidth, sideBarrelLength, BARREL_COLOR);  // Right
                }
                
                // Draw main barrel
                drawBarrel(0, actualBarrelWidth, actualBarrelLength, BARREL_COLOR);
                // Add a muzzle flash effect to the main barrel
                ctx.fillStyle = 'rgba(255, 223, 186, 0.7)';
                ctx.beginPath();
                ctx.arc(this.getBarrelTip().x, this.getBarrelTip().y, actualBarrelWidth/2, 0, Math.PI * 2);
                if(isShooting) ctx.fill();


                // 4. Draw Shield effect
                if (shieldActive) {
                    ctx.strokeStyle = 'cyan';
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    const shieldPulse = Math.sin(Date.now() / 150) * 5;
                    ctx.arc(pivot.x, pivot.y, this.width * 0.7 + shieldPulse, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            update() {
                const prevX = this.x;
                if (keys['ArrowLeft'] && this.x > 0) this.x -= this.speed;
                if (keys['ArrowRight'] && this.x < canvas.width - this.width) this.x += this.speed;
                this.x = Math.max(0, Math.min(this.x, canvas.width - this.width));

                // Barrel sway based on movement
                const moveDelta = this.x - prevX;
                const targetAngle = -90 * (Math.PI / 180) - (moveDelta * 0.5) * (Math.PI / 180);
                // Smoothly interpolate to the target angle
                this.barrelAngle += (targetAngle - this.barrelAngle) * 0.1;
            }
        }

        class Projectile {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.radius = 7;
                this.speed = 15;
                this.color = 'orange';
                this.vx = this.speed * Math.cos(angle);
                this.vy = this.speed * Math.sin(angle);
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
            }
        }

        class Balloon {
            constructor() {
                this.radius = Math.random() * 30 + 20;
                this.x = Math.random() * (canvas.width - this.radius * 2) + this.radius;
                this.y = -this.radius;
                const baseSpeed = Math.random() * 1.5 + 0.5;
                const intensity = parseFloat(difficultySlider.value);
                const difficultyFactor = (intensity / 10) * 1.5;
                this.speed = baseSpeed + difficultyFactor;
                this.isBomb = Math.random() < 0.08; // Slightly increased bomb chance
                this.color = this.isBomb ? '#333' : `hsl(${Math.random() * 360}, 100%, 50%)`;
                this.maxHealth = Math.floor(this.radius / 15) || 1;
                this.health = this.maxHealth;
                this.points = Math.floor(60 - this.radius);
            }
            draw() {
                ctx.save();
                if (this.isBomb) {
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#ff4500';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#111';
                    ctx.fill();
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#fff';
                    ctx.font = `${this.radius}px serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üíÄ', this.x, this.y);
                } else {
                    if (this.health < this.maxHealth) ctx.globalAlpha = 0.5 + (this.health / this.maxHealth) * 0.5;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
                ctx.restore();
            }
            update() { this.y += this.speed; }
        }

        class PowerUp {
            constructor(emoji, health = 1) {
                this.width = 50;
                this.height = 50;
                this.x = Math.random() * (canvas.width - this.width);
                this.y = -this.height;
                this.speed = 2;
                this.emoji = emoji;
                this.health = health;
                this.maxHealth = health;
            }
            draw() {
                ctx.font = '40px serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, this.x + this.width / 2, this.y + this.height / 2);
                if (this.maxHealth > 1) {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(this.x, this.y + this.height + 5, this.width, 10);
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x, this.y + this.height + 5, this.width * (this.health / this.maxHealth), 10);
                }
            }
            update() { this.y += this.speed; }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.radius = Math.random() * 3 + 1;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.alpha = 1;
            }
            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.restore();
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.alpha -= 0.08; // Increased alpha decay for faster fade
            }
        }

        // --- GAME FUNCTIONS ---

        function playSound(audioEl) {
            if (!isMuted) {
                audioEl.currentTime = 0;
                audioEl.play().catch(e => console.error("Sound playback failed:", e));
            }
        }

        function gainLife() {
            playSound(powerupSound);
            if (lives < MAX_LIVES) {
                lives++;
                updateLivesUI();
                powerupStatusEl.textContent = '‚ô• EXTRA LIFE GAINED!';
            } else {
                powerupStatusEl.textContent = '‚ô• MAX LIVES! (+100 Score)';
                score += 100;
                scoreboard.textContent = `Score: ${score}`;
            }
            setTimeout(() => {
                if (powerupStatusEl.textContent.includes('LIFE')) updatePowerupTimers();
            }, 1500);
        }

        function updateLivesUI() {
            livesDisplay.innerHTML = '';
            for (let i = 0; i < MAX_LIVES; i++) {
                const heart = document.createElement('span');
                heart.className = `text-2xl transition-colors duration-300`;
                heart.textContent = '‚ô•';
                heart.style.color = i < lives ? '#ff4081' : '#4b5563';
                livesDisplay.appendChild(heart);
            }
        }

        function loseLife() {
            if (shieldActive) {
                powerupStatusEl.textContent = 'üõ°Ô∏è SHIELD PROTECTED YOU!';
                setTimeout(() => {
                    if (powerupStatusEl.textContent.includes('SHIELD PROTECTED')) updatePowerupTimers();
                }, 1500);
                return;
            }
            if (lives <= 0) return;
            playSound(lifeLossSound);
            lives--;
            updateLivesUI();
            livesDisplay.classList.add('life-lost');
            setTimeout(() => livesDisplay.classList.remove('life-lost'), 300);
            if (lives <= 0) gameOver(false);
        }

        function init() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            
            const intensity = parseFloat(difficultySlider.value);
            balloonSpawnRate = 0.002 + (intensity - 1) * 0.00366;
            
            resizeCanvas();
            player = new Player();
            projectiles = [];
            balloons = [];
            particles = [];
            gunPowerups = [];
            lifePowerups = [];
            shieldPowerups = [];
            score = 0;
            lives = MAX_LIVES;
            scoreboard.textContent = 'Score: 0';
            updateLivesUI();
            
            gameRunning = true;
            isPaused = false;
            pausePlayBtn.textContent = 'Pause';
            multiGunActive = false;
            multiGunTimer = 0;
            shieldActive = false;
            shieldTimer = 0;
            powerupStatusEl.textContent = '';
            
            instructionPopup.classList.add('hidden');
            gameOverPopup.classList.add('hidden');
            
            if (!isMuted) bgMusic.play().catch(e => console.log("Music auto-play failed."));
            
            update();
        }

        function resizeCanvas() {
            const gameContainer = document.querySelector('body');
            const maxWidth = 800;
            const aspectRatio = 4 / 3;
            const w = Math.min(gameContainer.clientWidth * 0.95, maxWidth);
            const h = w / aspectRatio;
            canvas.width = w;
            canvas.height = h;
            if (player) player.y = canvas.height;
        }

        function shoot() {
            if (gameRunning && !isPaused) {
                const tip = player.getBarrelTip();
                const mainAngle = player.barrelAngle;
                projectiles.push(new Projectile(tip.x, tip.y, mainAngle));
                if (multiGunActive) {
                    const angleOffset = 10 * (Math.PI / 180);
                    projectiles.push(new Projectile(tip.x, tip.y, mainAngle - angleOffset));
                    projectiles.push(new Projectile(tip.x, tip.y, mainAngle + angleOffset));
                }
                playSound(shootSound);
            }
        }

        function updatePowerupTimers() {
            let statusText = '';
            if (multiGunTimer > 0) {
                multiGunTimer--;
                statusText += `üî´ Multi-Gun: ${Math.ceil(multiGunTimer / 60)}s`;
                multiGunActive = true;
            } else {
                multiGunActive = false;
            }
            if (shieldTimer > 0) {
                if (statusText) statusText += ' | ';
                shieldTimer--;
                statusText += `üõ°Ô∏è Shield: ${Math.ceil(shieldTimer / 60)}s`;
                shieldActive = true;
            } else {
                shieldActive = false;
            }
            powerupStatusEl.textContent = statusText;
        }

        function gameOver(isBombHit) {
            gameRunning = false;
            clearInterval(shootInterval);
            isShooting = false;
            bgMusic.pause();
            if (isBombHit) playSound(bombBlastSound);
            finalScoreEl.textContent = score;
            gameOverPopup.classList.remove('hidden');
        }

        function update() {
            if (!gameRunning) return;
            
            animationFrameId = requestAnimationFrame(update);

            if (isPaused) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Spawn items
            if (Math.random() < balloonSpawnRate) balloons.push(new Balloon());
            if (Math.random() < 0.002) gunPowerups.push(new PowerUp('üî´', 3));
            if (Math.random() < 0.001) shieldPowerups.push(new PowerUp('üõ°Ô∏è'));
            if (Math.random() < 0.0008) lifePowerups.push(new PowerUp('‚ô•'));

            player.update();
            player.draw();

            // Update projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.update();
                p.draw();
                if (p.y < -p.radius || p.x < -p.radius || p.x > canvas.width + p.radius) {
                    projectiles.splice(i, 1);
                }
            }

            // Update balloons
            for (let i = balloons.length - 1; i >= 0; i--) {
                const b = balloons[i];
                b.update();
                b.draw();

                if (b.y - b.radius > canvas.height) {
                    if (!b.isBomb) loseLife();
                    balloons.splice(i, 1);
                    continue;
                }

                for (let j = projectiles.length - 1; j >= 0; j--) {
                    const p = projectiles[j];
                    if (Math.hypot(p.x - b.x, p.y - b.y) - b.radius - p.radius < 1) {
                        projectiles.splice(j, 1);
                        if (b.isBomb) {
                            for (let k = 0; k < 100; k++) particles.push(new Particle(b.x, b.y, Math.random() < 0.5 ? '#ff4500' : '#111'));
                            gameOver(true);
                            return; // Exit update loop immediately
                        }
                        b.health--;
                        if (b.health <= 0) {
                            playSound(popSound);
                            for (let k = 0; k < b.radius / 2; k++) particles.push(new Particle(b.x, b.y, b.color));
                            score += b.points;
                            scoreboard.textContent = `Score: ${score}`;
                            balloons.splice(i, 1);
                            break; // Move to next balloon
                        }
                    }
                }
            }

            // Update powerups
            const allPowerups = [gunPowerups, shieldPowerups, lifePowerups];
            for (let type = 0; type < allPowerups.length; type++) {
                const powerupList = allPowerups[type];
                for (let i = powerupList.length - 1; i >= 0; i--) {
                    const item = powerupList[i];
                    item.update();
                    item.draw();

                    if (item.y > canvas.height) {
                        powerupList.splice(i, 1);
                        continue;
                    }

                    for (let j = projectiles.length - 1; j >= 0; j--) {
                        const p = projectiles[j];
                        const itemCenterX = item.x + item.width / 2;
                        const itemCenterY = item.y + item.height / 2;
                        if (Math.hypot(p.x - itemCenterX, p.y - itemCenterY) < item.width / 2 + p.radius) {
                            projectiles.splice(j, 1);
                            item.health--;
                            if (item.health <= 0) {
                                playSound(powerupSound);
                                powerupList.splice(i, 1);
                                if (type === 0) multiGunTimer = 10 * 60; // Gun
                                else if (type === 1) shieldTimer = 12 * 60; // Shield
                                else if (type === 2) gainLife(); // Life
                                break; // Move to next powerup
                            }
                        }
                    }
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                p.draw();
                if (p.alpha <= 0) particles.splice(i, 1);
            }

            updatePowerupTimers();
        }

        function togglePause() {
            isPaused = !isPaused;
            pausePlayBtn.textContent = isPaused ? 'Play' : 'Pause';
            if (isPaused) {
                bgMusic.pause();
                clearInterval(shootInterval);
            } else {
                if (!isMuted) bgMusic.play().catch(e => {});
                if (isShooting) shootInterval = setInterval(shoot, 150);
                // Restart animation loop if it was paused
                if (!animationFrameId) update();
            }
        }

        function toggleSound() {
            isMuted = !isMuted;
            soundToggleBtn.textContent = isMuted ? 'Sound On' : 'Sound Off';
            [bgMusic, shootSound, popSound, bombBlastSound, powerupSound, lifeLossSound].forEach(audio => audio.muted = isMuted);
            if (!isMuted && gameRunning && !isPaused) {
                bgMusic.play().catch(e => console.log("Music play failed on toggle."));
            } else {
                bgMusic.pause();
            }
        }

        // --- EVENT LISTENERS ---
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space' && !isShooting && gameRunning && !isPaused) {
                isShooting = true;
                shoot();
                shootInterval = setInterval(shoot, 150);
            }
        });
        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
            if (e.code === 'Space') {
                isShooting = false;
                clearInterval(shootInterval);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!player || isPaused) return;
            const rect = canvas.getBoundingClientRect();
            player.x = e.clientX - rect.left - player.width / 2;
        });
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!player || isPaused) return;
            const rect = canvas.getBoundingClientRect();
            if (e.touches.length > 0) player.x = e.touches[0].clientX - rect.left - player.width / 2;
        }, { passive: false });

        fireBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!isShooting && gameRunning && !isPaused) {
                isShooting = true;
                shoot();
                shootInterval = setInterval(shoot, 150);
            }
        }, { passive: false });
        fireBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            isShooting = false;
            clearInterval(shootInterval);
        }, { passive: false });

        pausePlayBtn.addEventListener('click', togglePause);
        soundToggleBtn.addEventListener('click', toggleSound);
        closeButton.addEventListener('click', init);
        startButton.addEventListener('click', init);

        window.onload = () => {
            resizeCanvas();
            updateLivesUI();
            instructionPopup.classList.remove('hidden');
        };
    </script>
</body>
</html>
